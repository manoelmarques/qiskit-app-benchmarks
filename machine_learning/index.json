{"project": "qiskit-machine-learning", "project_url": "https://qiskit.org/documentation/machine-learning/", "show_commit_url": "http://github.com/Qiskit/qiskit-machine-learning/commit/", "hash_length": 8, "revision_to_hash": {"616": "3a6a456bd0c78de570ddddd242c9f13ef9ac7abc", "1137": "e5c3c8d50f2337f46a6a5d0dbad05a1e4807b97e", "1359": "ec3cbccca8f8c588d1ac523f4b12dc8c0bcef5b9", "1479": "223c4127cf8874afeb349eba86d6bca1f498d14f"}, "revision_to_date": {"616": 1617272920000, "1137": 1626124407000, "1359": 1629808246000, "1479": 1632409954000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Core(TM) i7-3720QM CPU @ 2.60GHz"], "machine": ["buildkitsandbox"], "num_cpu": ["4"], "os": ["Linux 5.10.47-linuxkit"], "ram": ["9171308"], "python": ["3.8"], "sparse": [""], "torch": [""], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-3720QM CPU @ 2.60GHz", "machine": "buildkitsandbox", "num_cpu": "4", "os": "Linux 5.10.47-linuxkit", "ram": "9171308", "python": "3.8", "sparse": "", "torch": "", "branch": "main"}], "benchmarks": {"circuit_qnn_classifier_benchmark.CircuitQnnClassifierBenchmarks.time_predict_circuit_qnn_classifier": {"code": "class CircuitQnnClassifierBenchmarks:\n    def time_predict_circuit_qnn_classifier(self, _, __):\n        \"\"\"Time predicting with CircuitQNN classifier.\"\"\"\n    \n        y_predict = self.circuit_classifier_fitted.predict(self.X)\n        return y_predict\n\n    def setup(self, dataset, quantum_instance_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        self.y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n    \n        # parity maps bitstrings to 0 or 1\n        def parity(x):\n            return f\"{x:b}\".count(\"1\") % 2\n    \n        # construct feature map\n        feature_map = ZZFeatureMap(num_inputs)\n    \n        # construct ansatz\n        ansatz = RealAmplitudes(num_inputs, reps=1)\n    \n        # construct quantum circuit\n        qc = QuantumCircuit(num_inputs)\n        qc.append(feature_map, range(num_inputs))\n        qc.append(ansatz, range(num_inputs))\n    \n        # construct QNN\n        self.circuit_qnn = CircuitQNN(\n            circuit=qc,\n            input_params=feature_map.parameters,\n            weight_params=ansatz.parameters,\n            interpret=parity,\n            output_shape=self.output_shape,\n            quantum_instance=self.backends[quantum_instance_name],\n        )\n    \n        self.circuit_classifier_fitted = NeuralNetworkClassifier(\n            neural_network=self.circuit_qnn, optimizer=COBYLA()\n        )\n        self.circuit_classifier_fitted.fit(self.X, self.y01)", "min_run_count": 2, "name": "circuit_qnn_classifier_benchmark.CircuitQnnClassifierBenchmarks.time_predict_circuit_qnn_classifier", "number": 0, "param_names": ["backend name", "param2"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "43ea67c0bcd81cd5ef526b12423b5beec2bd445384012907c363e14c3c5531c4", "warmup_time": -1}, "circuit_qnn_classifier_benchmark.CircuitQnnClassifierBenchmarks.time_score_circuit_qnn_classifier": {"code": "class CircuitQnnClassifierBenchmarks:\n    def time_score_circuit_qnn_classifier(self, _, __):\n        \"\"\"Time scoring CircuitQNN classifier on data.\"\"\"\n    \n        self.circuit_classifier_fitted.score(self.X, self.y01)\n\n    def setup(self, dataset, quantum_instance_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        self.y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n    \n        # parity maps bitstrings to 0 or 1\n        def parity(x):\n            return f\"{x:b}\".count(\"1\") % 2\n    \n        # construct feature map\n        feature_map = ZZFeatureMap(num_inputs)\n    \n        # construct ansatz\n        ansatz = RealAmplitudes(num_inputs, reps=1)\n    \n        # construct quantum circuit\n        qc = QuantumCircuit(num_inputs)\n        qc.append(feature_map, range(num_inputs))\n        qc.append(ansatz, range(num_inputs))\n    \n        # construct QNN\n        self.circuit_qnn = CircuitQNN(\n            circuit=qc,\n            input_params=feature_map.parameters,\n            weight_params=ansatz.parameters,\n            interpret=parity,\n            output_shape=self.output_shape,\n            quantum_instance=self.backends[quantum_instance_name],\n        )\n    \n        self.circuit_classifier_fitted = NeuralNetworkClassifier(\n            neural_network=self.circuit_qnn, optimizer=COBYLA()\n        )\n        self.circuit_classifier_fitted.fit(self.X, self.y01)", "min_run_count": 2, "name": "circuit_qnn_classifier_benchmark.CircuitQnnClassifierBenchmarks.time_score_circuit_qnn_classifier", "number": 0, "param_names": ["backend name", "param2"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "c33dd04339cefa35adae18d58cce6778ab738332d88109513b537cd911361fdb", "warmup_time": -1}, "circuit_qnn_classifier_fit_benchmark.CircuitQnnFitClassifierBenchmarks.time_fit_circuit_qnn_classifier": {"code": "class CircuitQnnFitClassifierBenchmarks:\n    def time_fit_circuit_qnn_classifier(self, _, __, ___):\n        \"\"\"Time fitting CircuitQNN classifier to data.\"\"\"\n    \n        self.circuit_classifier.fit(self.X, self.y01)\n\n    def setup(self, dataset, quantum_instance_name, optimizer_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        self.y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n    \n        # construct feature map\n        feature_map = ZZFeatureMap(num_inputs)\n    \n        # construct ansatz\n        ansatz = RealAmplitudes(num_inputs, reps=1)\n    \n        # construct quantum circuit\n        qc = QuantumCircuit(num_inputs)\n        qc.append(feature_map, range(num_inputs))\n        qc.append(ansatz, range(num_inputs))\n    \n        # parity maps bitstrings to 0 or 1\n        def parity(x):\n            return f\"{x:b}\".count(\"1\") % 2\n    \n        # construct QNN\n        self.circuit_qnn = CircuitQNN(\n            circuit=qc,\n            input_params=feature_map.parameters,\n            weight_params=ansatz.parameters,\n            interpret=parity,\n            output_shape=self.output_shape,\n            quantum_instance=self.backends[quantum_instance_name],\n        )\n    \n        # construct classifier\n        self.circuit_classifier = NeuralNetworkClassifier(\n            neural_network=self.circuit_qnn, optimizer=self.optimizers[optimizer_name]\n        )", "min_run_count": 2, "name": "circuit_qnn_classifier_fit_benchmark.CircuitQnnFitClassifierBenchmarks.time_fit_circuit_qnn_classifier", "number": 0, "param_names": ["backend name", "optimizer", "param3"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"], ["'cobyla'", "'nelder-mead'", "'l-bfgs-b'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "cd98ea6705ac707bea8ba0bbf4fa15c6b9a0e7e8c7e0456d89b306504d6608b2", "warmup_time": -1}, "opflow_qnn_classifier_benchmark.OpflowQnnClassifierBenchmarks.time_predict_opflow_qnn_classifier": {"code": "class OpflowQnnClassifierBenchmarks:\n    def time_predict_opflow_qnn_classifier(self, _, __):\n        \"\"\"Time predicting with classifier OpflowQNN.\"\"\"\n    \n        y_predict = self.opflow_classifier_fitted.predict(self.X)\n        return y_predict\n\n    def setup(self, dataset, quantum_instance_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n        self.y = 2 * y01 - 1  # in {-1, +1}\n        opflow_qnn = TwoLayerQNN(num_inputs, quantum_instance=self.backends[quantum_instance_name])\n        opflow_qnn.forward(self.X[0, :], np.random.rand(opflow_qnn.num_weights))\n    \n        self.opflow_classifier_fitted = NeuralNetworkClassifier(opflow_qnn, optimizer=COBYLA())\n        self.opflow_classifier_fitted.fit(self.X, self.y)", "min_run_count": 2, "name": "opflow_qnn_classifier_benchmark.OpflowQnnClassifierBenchmarks.time_predict_opflow_qnn_classifier", "number": 0, "param_names": ["backend name", "param2"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "703270427f4b9d7f093a12216e6cab9ba8859ee037a07ca1ccfd72c9d08bd315", "warmup_time": -1}, "opflow_qnn_classifier_benchmark.OpflowQnnClassifierBenchmarks.time_score_opflow_qnn_classifier": {"code": "class OpflowQnnClassifierBenchmarks:\n    def time_score_opflow_qnn_classifier(self, _, __):\n        \"\"\"Time scoring OpflowQNN classifier on data.\"\"\"\n    \n        self.opflow_classifier_fitted.score(self.X, self.y)\n\n    def setup(self, dataset, quantum_instance_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n        self.y = 2 * y01 - 1  # in {-1, +1}\n        opflow_qnn = TwoLayerQNN(num_inputs, quantum_instance=self.backends[quantum_instance_name])\n        opflow_qnn.forward(self.X[0, :], np.random.rand(opflow_qnn.num_weights))\n    \n        self.opflow_classifier_fitted = NeuralNetworkClassifier(opflow_qnn, optimizer=COBYLA())\n        self.opflow_classifier_fitted.fit(self.X, self.y)", "min_run_count": 2, "name": "opflow_qnn_classifier_benchmark.OpflowQnnClassifierBenchmarks.time_score_opflow_qnn_classifier", "number": 0, "param_names": ["backend name", "param2"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "ef3b4008ded906a657c267686e8ec5dd67c2eb302c6cf461d60d39ccfbbd833b", "warmup_time": -1}, "opflow_qnn_classifier_fit_benchmark.OpflowQnnFitClassifierBenchmarks.time_fit_opflow_qnn_classifier": {"code": "class OpflowQnnFitClassifierBenchmarks:\n    def time_fit_opflow_qnn_classifier(self, _, __, ___):\n        \"\"\"Time fitting OpflowQNN classifier to data.\"\"\"\n    \n        self.opflow_classifier.fit(self.X, self.y)\n\n    def setup(self, dataset, quantum_instance_name, optimizer_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n        self.y = 2 * y01 - 1  # in {-1, +1}\n    \n        opflow_qnn = TwoLayerQNN(num_inputs, quantum_instance=self.backends[quantum_instance_name])\n        opflow_qnn.forward(self.X[0, :], np.random.rand(opflow_qnn.num_weights))\n    \n        self.opflow_classifier = NeuralNetworkClassifier(\n            opflow_qnn, optimizer=self.optimizers[optimizer_name]\n        )", "min_run_count": 2, "name": "opflow_qnn_classifier_fit_benchmark.OpflowQnnFitClassifierBenchmarks.time_fit_opflow_qnn_classifier", "number": 0, "param_names": ["backend name", "optimizer", "param3"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"], ["'cobyla'", "'nelder-mead'", "'l-bfgs-b'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "5990861cf86c1233afe627f106e58d5bf13af889bdea6365a038a48a3226d18e", "warmup_time": -1}, "vqc_benchmark.VqcBenchmarks.time_predict_vqc": {"code": "class VqcBenchmarks:\n    def time_predict_vqc(self, _, __):\n        \"\"\"Time predicting with VQC.\"\"\"\n    \n        y_predict = self.vqc_fitted.predict(self.X)\n        return y_predict\n\n    def setup(self, dataset, quantum_instance_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        num_samples = len(self.X)\n        y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n        self.y_one_hot = np.zeros((num_samples, 2))\n        for i in range(num_samples):\n            self.y_one_hot[i, y01[i]] = 1\n    \n        # construct feature map, ansatz, and optimizer\n        feature_map = ZZFeatureMap(num_inputs)\n        ansatz = RealAmplitudes(num_inputs, reps=1)\n        # construct variational quantum classifier\n        self.vqc_fitted = VQC(\n            feature_map=feature_map,\n            ansatz=ansatz,\n            loss=\"cross_entropy\",\n            optimizer=COBYLA(),\n            quantum_instance=self.backends[quantum_instance_name],\n        )\n    \n        self.vqc_fitted.fit(self.X, self.y_one_hot)", "min_run_count": 2, "name": "vqc_benchmark.VqcBenchmarks.time_predict_vqc", "number": 0, "param_names": ["backend name", "param2"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "8c6bb01c20de38de43daff95b5d1b334c1d121f873e1be96a9afb1d9ba4b8a78", "warmup_time": -1}, "vqc_benchmark.VqcBenchmarks.time_score_vqc": {"code": "class VqcBenchmarks:\n    def time_score_vqc(self, _, __):\n        \"\"\"Time scoring VQC on data.\"\"\"\n    \n        self.vqc_fitted.score(self.X, self.y_one_hot)\n\n    def setup(self, dataset, quantum_instance_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        num_samples = len(self.X)\n        y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n        self.y_one_hot = np.zeros((num_samples, 2))\n        for i in range(num_samples):\n            self.y_one_hot[i, y01[i]] = 1\n    \n        # construct feature map, ansatz, and optimizer\n        feature_map = ZZFeatureMap(num_inputs)\n        ansatz = RealAmplitudes(num_inputs, reps=1)\n        # construct variational quantum classifier\n        self.vqc_fitted = VQC(\n            feature_map=feature_map,\n            ansatz=ansatz,\n            loss=\"cross_entropy\",\n            optimizer=COBYLA(),\n            quantum_instance=self.backends[quantum_instance_name],\n        )\n    \n        self.vqc_fitted.fit(self.X, self.y_one_hot)", "min_run_count": 2, "name": "vqc_benchmark.VqcBenchmarks.time_score_vqc", "number": 0, "param_names": ["backend name", "param2"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "38caee26d58f536d618399ba25934972a9d7261f659305aab6086a1c31c2e017", "warmup_time": -1}, "vqc_fit_benchmark.VqcFitBenchmarks.time_fit_vqc": {"code": "class VqcFitBenchmarks:\n    def time_fit_vqc(self, _, __, ___, ____):\n        \"\"\"Time fitting VQC to data.\"\"\"\n    \n        self.vqc.fit(self.X, self.y_one_hot)\n\n    def setup(self, dataset, quantum_instance_name, optimizer_name, loss_name):\n        \"\"\"setup\"\"\"\n        self.X = self.datasets[dataset]\n        num_inputs = len(self.X[0])\n        num_samples = len(self.X)\n        y01 = 1 * (np.sum(self.X, axis=1) >= 0)  # in { 0,  1}\n        self.y_one_hot = np.zeros((num_samples, 2))\n        for i in range(num_samples):\n            self.y_one_hot[i, y01[i]] = 1\n        # construct feature map, ansatz, and optimizer\n        feature_map = ZZFeatureMap(num_inputs)\n        ansatz = RealAmplitudes(num_inputs, reps=1)\n    \n        # construct variational quantum classifier\n        self.vqc = VQC(\n            feature_map=feature_map,\n            ansatz=ansatz,\n            loss=loss_name,\n            optimizer=self.optimizers[optimizer_name],\n            quantum_instance=self.backends[quantum_instance_name],\n        )", "min_run_count": 2, "name": "vqc_fit_benchmark.VqcFitBenchmarks.time_fit_vqc", "number": 0, "param_names": ["backend name", "optimizer", "loss function", "param4"], "params": [["'dataset_1'"], ["'qasm_simulator'", "'statevector_simulator'"], ["'cobyla'", "'nelder-mead'", "'l-bfgs-b'"], ["'cross_entropy'", "'squared_error'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 1200.0, "type": "time", "unit": "seconds", "version": "9b78267f694df7fc2d59160872cec1531d876ade2dc5bd4fefc00ba52738cb02", "warmup_time": -1}}, "machines": {"buildkitsandbox": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-3720QM CPU @ 2.60GHz", "machine": "buildkitsandbox", "num_cpu": "4", "os": "Linux 5.10.47-linuxkit", "ram": "9171308", "version": 1}}, "tags": {"0.1.0": 616, "0.2.0": 1137, "0.2.1": 1359}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}